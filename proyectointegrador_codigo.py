# -*- coding: utf-8 -*-
"""proyectoIntegrador-Codigo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D0DIwOn7wDaeZdMlzeD665nyNx2nNnXW

# **1. Instalación de librerías**
"""

!pip install seaborn
!pip install pandas
!pip install numpy
!pip install matplotlib
!pip install scikit-learn
!pip install tabulate

"""# **2. Importación de librerías**"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from tabulate import tabulate

"""# **3. Información de columnas**

Se trae el archivo csv del campus virtual al código para que sea asignado como datos
"""

datos=pd.read_csv("proyectoIntegrador.csv")
datos

"""Por medio del .shape se pueden observar el tamaño de las columnas, siendo un total de 1940977 filas y 26 columnas

"""

datos.shape

"""Por medio del .info() se observan los nombres de las columnas, el tipo de dato que es contando con objetos, enteros o decimales donde hay un total de: float64(3), int64(10), object(13)"""

datos.info()

"""Por medio del .isna() se sacan los nulos del dataset y el .sum() los suma y los muestra de acuerdo a las columnas"""

datos.isna().sum()

"""El .columns muestra los nombres de las columnas del dataset"""

datos.columns

"""Muestra los datos unicos de la columna tabla"""

datos["tabla"].unique()

"""muestra los datos únicos de la columna destino


"""

datos["destino"].unique()

"""Muestra los datos únicos de la columna rol"""

datos["rol"].unique()

"""Muestra los datos únicos de la columna evento"""

datos["evento"].unique()

"""Muestra los datos únicos de la columna accion"""

datos["accion"].unique()

"""Muestra los datos únicos de la columna crud"""

datos["crud"].unique()

"""Muestra los datos únicos de la columna categoria"""

datos["categoria"].unique()

"""# **4. Reemplazo de variables**

Se reemplazan 3 columnas de tipo object a tipo int64 con el fin de poder crear graficas de análisis del comportamiento de estas columnas.

Se reemplazan los valores de la columna crud donde u=1,c=2,r=3,d=4
"""

valores={"crud":{'u':1,'c':2,'r':3,'d':4}}
datos.replace(valores,inplace=True)

"""Se reemplazan los valores de la columna rol donde editingteacher=1,student=2."""

valores={"rol":{'editingteacher':1,'student':2}}
datos.replace(valores,inplace=True)

"""Se reemplazan los valores de la categoría donde LICENCIATURA EN ESPAÑOL Y LENGUAS EXTRANJERAS INGLÉS Y FRANCÉS=11 y '9'=9."""

valores={"categoria":{'LICENCIATURA EN ESPAÑOL Y LENGUAS EXTRANJERAS INGLÉS Y FRANCÉS':11,'9':9}}
datos.replace(valores,inplace=True)
datos['categoria'].unique()

"""Se vuelven a mostrar los datos con él .info() para confirmar el cambio de variable a entero"""

datos.info()

"""# **5. Análisis de datos**

Se realiza una gráfica de barras entre el los roles profesor estudiante para ver cuál de los 2 realizan más peticiones en respecto al crud
"""

g = sns.catplot(x="crud",data= datos,kind="count",hue="rol")

"""Se realiza una gráfica de barras de acuerdo a la cantidad de peticiones que se hacen en el crud donde la mayor cantidad que se realiza es en la 3('r') read"""

datos['crud'].value_counts().sort_index().plot.bar()
plt.title("cantidad de repeticiones de CRUD")
plt.xlabel("crud")
plt.ylabel("cantidad de veces realizado")
plt.show()

"""Este es un diagrama de barras de categorías, se observa que la categoría que más se repite es la 1 y la cantidad que menos se repite es la 11."""

datos['categoria'].value_counts().sort_index().plot.bar()
plt.title("cantidad de repeticiones de categoria")
plt.xlabel("categoria")
plt.ylabel("cantidad de veces realizado")
plt.show()

"""Mediante esta gráfica de línea se observa la cantidad de peticiones que se presentan a lo largo de las 11 categorías, mostrando que a medida que aumenta la categoría disminuye la cantidad de peticiones."""

plt.figure(figsize=(20, 10))
plt.plot(datos['categoria'].value_counts().sort_index())
plt.title("Gráfica de línea de cantidad de peticiones de categoría",fontsize=24)
plt.xlabel("semestre(Categoria)",fontsize=24)
plt.ylabel("cantidad de peiticiones",fontsize=24)
plt.grid(True)
plt.show()

"""Se realiza un diagrama de puntos de acuerdo a la categoría, contra el id de las peticiones realizadas por los estudiantes y los docentes"""

plt.scatter(x=datos["categoria"],y=datos["idevento"])
plt.title(" categoría VS idevento ")
plt.xlabel("categoría")
plt.ylabel("idevento")

"""En este diagrama de puntos se busca ver la cantidad de peticiones que hace el curso de acuerdo al categoría"""

plt.scatter(datos['idcurso'],datos['categoria'])
plt.show
plt.title(" idcurso VS categoria ",fontsize=24)
plt.xlabel("idcurso",fontsize=24)
plt.ylabel("categoria",fontsize=24)#(semestre)

"""Se realiza un diagrama de barras de curso, tomando como referencia el id del curso, para poder localizar el curso se coloca el id en un filtro en Excel para saber de cual curso se trata"""

plt.figure(figsize=(500, 10))
datos['idcurso'].value_counts().sort_index().plot.bar()
plt.title("Gráfico de barras   de curso",fontsize=30)
plt.xlabel("código del curso",fontsize=30)
plt.ylabel("cantidad de veces realizado",fontsize=30)
plt.show()
#Diagrama de barras de idcurso

"""Se realiza un histograma de frecuencia del curso (este tipo de diagrama es general)"""

datos["idcurso"].hist()
plt.title("Histograma de curso",fontsize=24)
plt.xlabel("Código del curso",fontsize=24)
plt.ylabel("cantidad de veces realizado",fontsize=24)
# Se realiza el histograma general de idcurso

"""# 6. Modelado"""

datos = datos.drop(columns=["evento","componente","tabla","origen","idobjeto","idusuarioreal","idusuarioafectado","accion","ip","destino","curso","usuario","email"])

"""Estas variables fueron dropeadas, ya que muchas de sus propiedades eran complicadas de tratar, tenían muchos datos nulos o no se entendía su significado"""

datos.info()

"""Aquí se muestran las variables que quedan, con estas variables se realizara el entrenamiento"""

corr_matrix=datos.corr()
plt.figure(1,figsize=(15,8))
sns.heatmap(corr_matrix,center=0,annot=True)

"""Esta es el diagrama de calor de las variables que quedaron"""

from sklearn.model_selection import train_test_split
x = datos.drop(columns = "rol")
y = datos["rol"]

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.2,random_state = 0)

"""por medio de este código se separan los datos de entrenamiento y de prueba en 20%"""

from sklearn.tree import DecisionTreeRegressor
modelo = DecisionTreeRegressor(max_depth = 10)
modelo.fit(x_train,y_train)
y_pred = modelo.predict(x_test)
print("Precisión por arboles de decision: ", modelo.score(x_train,y_train))

"""se realiza el entrenamiento de árboles de decisión de regresión"""

from sklearn.tree import plot_tree
from sklearn.tree import export_graphviz
from sklearn.tree import export_text
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import mean_squared_error, r2_score

"""Importación de librerías para el uso de algoritmos"""

importancia_predictores = pd.DataFrame(
    {'Predictor' :datos.drop(columns = 'rol').columns,
    'Importancia':modelo.feature_importances_}
)
print("Importancia de los predictores en el modelo ")
importancia_predictores.sort_values('Importancia',ascending=False)

"""Esta tabla muestra los datos que más afectaron o que mas tienen relación con el algoritmo"""

rmse = mean_squared_error(
    y_true = y_test,
    y_pred = y_pred
)
print(f"El error(rmse) de test es: {rmse}")

"""Se muestra el porcentaje de error

Es algoritmo tardo cerca de 16 segundos, y este acertó con 10 ramificaciones un 91%, con un error de 0.015

Tiempo de ejecución es de 9.53 segundos con 10 ramas
"""

from sklearn.model_selection import train_test_split
x = datos.drop(columns = "rol")
y = datos["rol"]
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.2,random_state = 0)

"""Por medio de este código se separan los datos de entrenamiento y de prueba en 20%"""

from sklearn.tree import DecisionTreeClassifier
modelo = DecisionTreeClassifier(max_depth = 3)
modelo.fit(x_train,y_train)
y_pred = modelo.predict(x_test)
print("Precisión por arboles de clasificación: ", modelo.score(x_train,y_train))

"""Se realiza el algoritmo de árboles de clasificación"""

rmse = mean_squared_error(
    y_true = y_test,
    y_pred = y_pred
)
print(f"El error(rmse) de test es: {rmse}")

"""El error del algoritmo es de 0.04

Tiempo de ejecución 5.13 segundos con solo 3 ramas

Este algoritmo tardo cerca de 5 segundos en realizarse y solo se necesitaron 3 ramificaciones con un acierto de 94% por lo que se considera el algoritmo óptimo para los datos elegidos en el data set(teniendo en cuanta que la variable de salida fue el rol), error de 0.22
"""

from sklearn.model_selection import train_test_split
x= datos.drop(columns = "rol")
y = datos["rol"]
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.2,random_state = 0)

"""Por medio de este código se separan los datos de entrenamiento y de prueba en 20%/80%"""

from sklearn.neighbors import KNeighborsRegressor
modelo = KNeighborsRegressor(n_neighbors =3 , metric = 'minkowski', p=2)
modelo.fit(x_train,y_train)
y_pred = modelo.predict(x_test)
print("Precisión por vecino mas cercano (entrenamiento): ", modelo.score(x_train,y_train))
print("Precisión por vecino mas cercano (prueba): ", modelo.score(x_train,y_train))

"""Se realiza el algoritmo KNN"""

rmse = mean_squared_error(
    y_true = y_test,
    y_pred = y_pred
)
print(f"El error(rmse) de test es: {rmse}")

"""El tiempo de ejecución es de 1.13 segundos

Su precisión es del 97% pero tardo cerca de 36 segundos, por lo tanto, este algoritmo consume más recursos del computador con un error de 0.08

# 7. Predicciones

Simulacion que predice la cantidad de eventos realizados tanto por estudiantes como por profesores un lapso de 2 años(720)
"""

#Columna utilizada
datos_crud = datos['crud']
datos_rol_est = datos[datos["rol"] == 1]
datos_rol_prof = datos[datos["rol"] == 2]
datos_crud_est = datos_rol_est['crud']
datos_crud_prof = datos_rol_prof['crud']

#Datos
n_simulaciones = 1000
dias_en_2a = 360 * 2  # Días en 2 años

#Inicialización de matrices de predicciones
predicciones = np.zeros(n_simulaciones)
predicciones_est = np.zeros(n_simulaciones)
predicciones_prof = np.zeros(n_simulaciones)

#Parámetros del modelo
media = np.mean(datos_crud)
desviacion_estandar = np.std(datos_crud)
media_est = np.mean(datos_crud_est)
desviacion_estandar_est = np.std(datos_crud_est)
media_prof = np.mean(datos_crud_prof)
desviacion_estandar_prof = np.std(datos_crud_prof)

#Simulación de Monte Carlo
for i in range(n_simulaciones):
    predicciones[i] = np.random.normal(media, desviacion_estandar, dias_en_2a).sum()
    predicciones_est[i] = np.random.normal(media_est, desviacion_estandar_est, dias_en_2a).sum()
    predicciones_prof[i] = np.random.normal(media_prof, desviacion_estandar_prof, dias_en_2a).sum()

#Predicción final
media_total = np.mean(predicciones)
media_total_est = np.mean(predicciones_est)
media_total_prof = np.mean(predicciones_prof)

#Promedios
print(f"Media total de eventos realizados de las variables crud dentro de dos años: {media_total:.4f}")
print(f"Media de eventos realizados de las variables crud dentro de dos años para estudiantes: {media_total_est:.4f}")
print(f"Media de eventos realizados de las variables crud de dos años para profesores: {media_total_prof:.4f}")

#Gráfica (histograma)
plt.figure(figsize=(10, 6))
plt.hist(predicciones_est, bins=30, alpha=0.5, label='Estudiantes')
plt.hist(predicciones_prof, bins=30, alpha=0.5, label='Profesores')
plt.xlabel('Número de eventos')
plt.ylabel('Frecuencia')
plt.title('Predicción de eventos por rol en dos años')
plt.legend()
plt.show()

"""Simulacion predictiva acerca de la cantidad de eventos realizados en un año tomando como dato central para llevarla a cabo "idevento"
"""

#Columna utilizada
datos_id_evento = datos['idevento']

#Parámetros del modelo
n_simulaciones = 1000
dias_en_1a = 360  #Días en 1 año

#Cálculo de la media y desviación estándar
media = np.mean(datos_id_evento)
desviacion_estandar = np.std(datos_id_evento)

#Inicialización de la matriz de predicciones
predicciones_por_dia = np.zeros((n_simulaciones, dias_en_1a))

#Simulación de Monte Carlo
for i in range(n_simulaciones):
    predicciones_por_dia[i] = np.random.normal(media, desviacion_estandar, dias_en_1a)

#Predicción final (promedio de todas las simulaciones por día)
media_predicciones_por_dia = np.mean(predicciones_por_dia, axis=0)

#Predicción total de eventos en un año
media_total_id_evento = np.sum(media_predicciones_por_dia)
print(f"Media total de eventos en un periodo de un año: {media_total_id_evento:.4f}")

# Gráfica de líneas
plt.figure(figsize=(10, 6))
plt.plot(media_predicciones_por_dia)
plt.xlabel('Tiempo (días)')
plt.ylabel('Número de eventos')
plt.title('Predicción de eventos en un año')
plt.show()

"""Simulación que toma como datos base en categoria(semestre) 2,5,10 para la cantidad de interacciones o peticiones que estos realizaran en un lapso de 1 año en la plataforma virtual, evidenciando que conforme los estudiantes avancen en la carrera realizan una menor cantidad de peticiones en el campus virtual."""

n_simulaciones = 1000
dias_en_1a = 360  # Dias en 1 año

#Simulación de Monte Carlo
def simular_categoria(datos_categoria):
    media = np.mean(datos_categoria)
    desviacion_estandar = np.std(datos_categoria)
    predicciones_por_dia = np.zeros((n_simulaciones, dias_en_1a))

    for i in range(n_simulaciones):
        predicciones_por_dia[i] = np.random.normal(media, desviacion_estandar, dias_en_1a)

    # Predicción final (promedio de todas las simulaciones por día)
    media_predicciones_por_dia = np.mean(predicciones_por_dia, axis=0)
    return media_predicciones_por_dia

# Categorías específicas a analizar
categorias = [2, 5, 10]

# Graficar predicciones para cada categoría
plt.figure(figsize=(15, 10))

for categoria in categorias:
    datos_categoria = datos[datos['categoria'] == categoria]['idevento']
    media_predicciones_por_dia = simular_categoria(datos_categoria)

    plt.plot(media_predicciones_por_dia, label=f'Categoría {categoria}')

plt.xlabel('Tiempo (días)')
plt.ylabel('Número de eventos')
plt.title('Predicción de eventos en categoria 2,5 y 10 en un año')
plt.legend()
plt.show()